using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using CheckersGame;


namespace CheckersGame
{    // ----------- INTERFACES ----------------
    public enum PieceType { Men, King };
    public enum PieceColor { Black, White };

    public interface IPlayer
    {
        string Name { get; }
        PieceColor Color { get; }
        // IEnumerable<IPiece> Pieces { get; }
    }


    public interface IBoard
    {
        ISquare GetSquare(int x, int y);
        IEnumerable<ISquare> Squares { get; }

        // -----
        // ADDITIONES
        // -----  
        void PrintBoard(); // PrintBoard accessible via interface IBoard
    }

    public interface ISquare
    {
        Position Position { get; }
        IPiece Piece { get; set; } // is occupied by a piece or null
        bool IsEmpty { get; }
    }

    public interface IPiece
    {
        PieceColor Color { get; }
        PieceType Type { get; }

    }

    // ----------- IMPLEMENTATIONS ----------------

    public class Move
    {
        public Position From { get; }
        public Position To { get; }
        public IPiece? CapturedPiece { get; set; }
        public Position? CapturedPosition { get; set; }

        public Move(Position from, Position to)
        {
            From = from;
            To = to;
        }

        public override string ToString()
        {
            string move = $"From: {From}, To: {To} ";
            if (CapturedPiece!=null)
            {
                move += $"Captured a Piece {CapturedPiece}";
            }
            return move;
        }

    }
    public class Player : IPlayer
    {
        public string Name { get; private set; }
        public PieceColor Color { get; private set; }
        // public IEnumerable<IPiece> Pieces { get; private set; }
        public Player(string name, PieceColor color)
        {
            Name = name;
            Color = color;
            // Pieces = new List<IPiece>();
        }
    }

    public struct Position
    {
        public int X { get; }
        public int Y { get; }

        public Position(int x, int y)
        {
            X = x;
            Y = y;
        }
    }
    public class Square : ISquare
    {
        public Position Position { get; private set; }
        public IPiece Piece { get; set; }
        public bool IsEmpty => Piece == null;

        public Square(Position position, IPiece piece = null)
        {
            Position = position;
            Piece = piece;
        }

        // -----
        // ADDITIONES
        //-----  
        public override string ToString()
        {
            if (Piece == null)
                return "   "; // empty square

            // Print Piece
            string symbol = Piece.Type == PieceType.Men ? "M" : "K";
            return Piece.Color == PieceColor.White ? $" W{symbol}" : $" B{symbol}";
        }
    }
    public class Piece : IPiece
    {
        public PieceColor Color { get; private set; }
        public PieceType Type { get; private set; }
        public Piece(PieceColor color, PieceType type)
        {
            Color = color;
            Type = type;
        }
    }
    public class Board : IBoard
    {
        // private ISquare[8, 8] _squares;
        // _Squares will be initialized in the constructor
        // _squares will contain ISquare objects for dark squares and null for light squares
        private readonly ISquare[,] _squares = new ISquare[8, 8];

        // Enumerable of all squares on the board
        // Enumerable will skip null squares
        // Enumerable will be used to initialize pieces on the board
        // Enumerable will be used to display the board
        // Foreach square will be accessed by its position (x, y)
        // Only dark squares will be initialized, light squares will be null
        // Dark squares are those where (x + y) % 2 == 1
        // (x + y) % 2 == 0 are light squares because if (X + Y) is even, both X and Y are either even or odd
        // Dark squares will be at positions (1,0), (3,0), (5,0), (7,0), (0,1), (2,1), (4,1), (6,1), etc.
        // Light squares will be at positions (0,0), (2,0), (4,0), (6,0), (1,1), (3,1), (5,1), (7,1), etc.
        // Only 32 squares will be initialized, 16 for each player
        // Black pieces will be initialized on rows 0, 1, 2
        // White pieces will be initialized on rows 5, 6, 7
        // Each square will be initialized with its position and a piece if occupied
        // Black pieces will be initialized with PieceType
        // Dark squares will be initialized with their position and no piece
        // Light squares will be null
        // Foreach just keep getting squares from the array and yield return them if not null until all squares are processed
        public IEnumerable<ISquare> Squares
        {
            get
            {
                foreach (var square in _squares)
                    if (square != null)
                        yield return square;
                    else
                        continue;
            }
        }

        public ISquare GetSquare(int x, int y)
        {
            return _squares[x, y];
        }

        public Board()
        {
            for (int y = 0; y < 8; y++)

            {
                for (int x = 0; x < 8; x++)
                {
                    _squares[x, y] = new Square(new Position(x, y));
                }
            }

            // -----
            // ADDITIONES
            // -----  
            InitializePieces();
        }

        // Explicit interface implementation = method only be accessed through the interface (hide the method from the class)
        // accessing method through interface is done by casting the class to the interface, for example:
        // IBoard board = new Board();
        // Returntype methodName(parameters) { ... }

        // Implicit means that the method can be accessed through the class
        // Here, we want to hide the GetSquare method from the Board class
        // This is done to prevent direct access to the squares array
        // This method can only be accessed through the IBoard interface   
        // Returntype Owner.MethodName(parameters)
        // ISquare is used because in IBoard interface, GetSquare method returns ISquare
        // This is done to hide the implementation details of the Board class
        // This is a common practice in C# to provide a clean interface
        // This method returns the square at the given coordinates
        ISquare IBoard.GetSquare(int x, int y)
        {
            if (x < 0 || x >= 8 || y < 0 || y >= 8)
                throw new ArgumentOutOfRangeException("Coordinates out of bounds");
            return _squares[x, y];
        }

        // -----
        // ADDITIONES
        // -----  
        private void InitializePieces()
        {
            // place black (top rows)
            for (int y = 0; y < 3; y++)
                for (int x = 0; x < 8; x++)
                    if ((x + y) % 2 == 1)
                        _squares[x, y].Piece = new Piece(PieceColor.Black, PieceType.Men);

            // place white (bottom rows)
            for (int y = 5; y < 8; y++)
                for (int x = 0; x < 8; x++)
                    if ((x + y) % 2 == 1)
                        _squares[x, y].Piece = new Piece(PieceColor.White, PieceType.Men);
        }

        // -----
        // ADDITIONES
        // -----  
        public void PrintBoard()
        {
            Console.WriteLine("    A  B  C  D  E  F  G  H");
            for (int y = 7; y >= 0; y--)
            {
                Console.Write($" {y + 1} ");
                for (int x = 0; x < 8; x++)
                {
                    var sq = _squares[x, y];
                    bool dark = (x + y) % 2 == 1;
                    Console.BackgroundColor = dark ? ConsoleColor.DarkGray : ConsoleColor.Gray;
                    Console.ForegroundColor = ConsoleColor.White;
                    Console.Write(sq.ToString());
                }
                Console.ResetColor();
                Console.WriteLine($" {y + 1}");
            }
            Console.WriteLine("    A  B  C  D  E  F  G  H");
            Console.ResetColor();
        }


    }
    public class GameController
    {
        private IBoard _board;
        private List<IPlayer> _players;
        private int _currentTurn;
        private Stack<(ISquare From, ISquare To, IPiece? Captured)> _moveHistory = new();
        public IPlayer CurrentPlayer
        {
            get
            {
                int index = _currentTurn % _players.Count;
                return _players[index];
            }
        }
        // public IPlayer CurrentPlayer => _players[_currentTurn % _players.Count];

        // +Action<.Player>? OnTurnChanged

        // +Action<ISquare, ISquare>? OnMoveApplied
        public GameController(IBoard board, List<IPlayer> players)
        {
            _board = board;
            _players = players;
            _currentTurn = 0;
        }
        public void StartGame()
        {
            Console.WriteLine("Game started");
            _board.PrintBoard();
        }
        public void SwitchTurn()
        {

        }
        // public GetAllPossibleMoves(){}

        public bool ValidateMove()
        {
            return true;
        }
        public void ApplyMove(Move move)
        {
            //Heres
            var fromSquare = _board.GetSquare(move.From.X, move.To.Y);
            var toSquare = _board.GetSquare(move.From.X, move.To.Y);

            if (fromSquare.IsEmpty)
            {
                throw new ArgumentException("There is no piece at starting position!"); //InvalidOperationException
            }

            toSquare.Piece = fromSquare.Piece;
            fromSquare.Piece = null;

            int horizontalChange = move.To.X - move.From.X;
            int verticalChange = move.To.Y - move.From.Y;

            int absHorizontalChange = Math.Abs(horizontalChange);
            int absVerticalChange = Math.Abs(verticalChange);

            // check if a jump is capture (simplified version)
            if (absHorizontalChange == 2 && absVerticalChange == 2)
            {
                //find captured piece position
                int capturedPieceX = (move.From.X - move.To.X); //Taking the average (from + to) / 2 = gives that midpoint
                int capturedPieceY = (move.From.Y - move.To.Y);

                var captured = _board.GetSquare(capturedPieceX, capturedPieceY);
                //captured is the square that should contain the opponent’s piece.

                if (!captured.IsEmpty)
                {
                    move.CapturedPiece = captured.Piece;
                    move.CapturedPosition = captured.Position;
                    captured.Piece = null;
                }
            }



        }
        public bool IsGameOver()
        {
            return false;
        }
        public bool HasAdditionalMove()
        {
            return false;
        }


    }
}

//     _moveHistory.Push(move.ToString());
//     SwitchTurn();
// }
class Program
{
    public static void Main(string[] args)
    {
        // IBoard board = new Board();
        // CheckersGame.IBoard board = new CheckersGame.Board();
        // board.PrintBoard();
        Board board = new Board();
        var players = new List<IPlayer>
            {
                new Player("Zen", PieceColor.Black),
                new Player("Afif", PieceColor.White)
            };

        var game = new GameController(board, players);
        game.StartGame();

        Console.WriteLine($"Player now : {game.CurrentPlayer.Name}");

        // Panggil explicit implementation
        CheckersGame.ISquare square = board.GetSquare(0, 0);

        Console.WriteLine(square.Position.X); // akses property Position
        Console.WriteLine(square.IsEmpty);    // akses property IsEmpty

    }
}



// while (true)
// {
//     Console.Clear();
//     _board.PrintBoard();   // show current state
//     Console.WriteLine($"Turn: {CurrentPlayer.Name}");

//     Console.Write("Enter move (fromX fromY toX toY): ");
//     string input = Console.ReadLine();

//     if (string.IsNullOrWhiteSpace(input)) break; // exit if blank

//     var parts = input.Split(' ');
//     if (parts.Length != 4) continue;

//     int fromX = int.Parse(parts[0]);
//     int fromY = int.Parse(parts[1]);
//     int toX = int.Parse(parts[2]);
//     int toY = int.Parse(parts[3]);

//     var move = new Move
//     {
//         From = new Position(fromX, fromY),
//         To = new Position(toX, toY)
//     };

//     try
//     {
//         ApplyMove(move);
//         _currentTurn++;
//     }
//     catch (Exception ex)
//     {
//         Console.WriteLine("Invalid move: " + ex.Message);
//         Console.ReadKey();
//     }
// }

